@page "/Kubernetes"
@using Microsoft.JSInterop
@using Microsoft.AspNetCore.Http
@inject k8s.IKubernetes Client
@inject NavigationManager NavigationManager
@inject ILogger<KubernetesDashboard> Logger
@inject IJSRuntime JS
@inject IHttpContextAccessor HttpContextAccessor
@inject IUserPreferenceRepository UserPreference
@attribute [Authorize]

@if (Error != null)
{
    <ul class="list-group mb-3">
        <li class="list-group-item list-group-item-danger">@Error</li>
    </ul>
}

<h3>Kubernetes</h3>

<div class="row">
    <button class="btn btn-primary"
            type="button"
            @onclick='() => Collapsing("collapseNamespace")'>
        Namespaces
    </button>
</div>


<div class="@Settings.NamespaceCollapseClass" id="collapseNamespace">
    <table class="table table-hover table-responsive">
        <caption>Table of kubernetes namespace</caption>
        <thead>
            <tr>
                <th>Name</th>
                <th>Creation time</th>
                <th>Phase</th>
                <th></th>
            </tr>
        </thead>
        <tbody>
            @foreach (var ns in NamespaceList)
            {
                <tr>
                    <td>@ns.Metadata.Name</td>
                    <td>@ns.Metadata.CreationTimestamp</td>
                    <td>@ns.Status.Phase</td>
                    <td>
                        <button id="@string.Concat("ns-", ns.Metadata.Name)"
                                title="btn-delete-ns-@ns.Metadata.Name"
                                class="btn btn-danger"
                                @onclick="async (mea) => await DeleteNamespace(ns)">
                            Delete
                        </button>
                    </td>
                </tr>
            }
        </tbody>
    </table>
</div>

<hr />

<div class="row">
    <button class="btn btn-primary"
            type="button"
            @onclick='() => Collapsing("collapseDeployment")'>
        Deployments
    </button>
</div>

<div class="@Settings.DeploymentCollapseClass" id="collapseDeployment">
    <table class="table table-hover table-responsive">
        <caption>Table of kubernetes deployments</caption>
        <thead>
            <tr>
                <th>Name</th>
                <th>Creation time</th>
                <th>Ready</th>
                <th>Unavailable</th>
                <th></th>
            </tr>
        </thead>
        <tbody>
            @foreach (var deployment in Deployments)
            {
                var deploymentNamespace = deployment.Namespace();
                var deploymentName = deployment.Name();

                <tr>
                    <td>@deployment.Metadata.Name</td>
                    <td>@deployment.Metadata.CreationTimestamp</td>
                    <td>@deployment.Status.ReadyReplicas</td>
                    <td>@deployment.Status.UnavailableReplicas</td>
                    <td>
                        <input id="@string.Concat(deploymentNamespace, deploymentName)"
                               title="button-pod-@deployment.Metadata.Name"
                               type="checkbox"
                               class="form-check"
                               @onchange="async (changeEventArg) => await OnDeploymentLogClick(changeEventArg, deploymentNamespace, deploymentName)" />
                    </td>
                </tr>
            }
        </tbody>
    </table>
</div>

<hr />

<div class="row">
    <button class="btn btn-primary"
            type="button"
            @onclick='() => Collapsing("collapsePods")'>
        Pods
    </button>
</div>

<div class="@Settings.PodsCollapseClass" id="collapsePods">
    <table class="table table-hover table-responsive">
        <caption>Table of kubernetes pods</caption>
        <thead>
            <tr>
                <th>Name</th>
                <th>Creation time</th>
                <th>Phase</th>
                <th>Reason</th>
                <th>Select</th>
            </tr>
        </thead>
        <tbody>
            @foreach (var pod in Pods)
            {
                var podNamespace = pod.Namespace();
                var podName = pod.Name();

                <tr>
                    <td>@pod.Metadata.Name</td>
                    <td>@pod.Metadata.CreationTimestamp</td>
                    <td>@pod.Status.Phase</td>
                    <td>@pod.Status.Reason</td>
                    <td>
                        <input id="@string.Concat(podNamespace, podName)"
                               title="button-pod-@pod.Metadata.Name"
                               type="checkbox"
                               class="form-check"
                               @onchange="async (changeEventArg) => await OnPodLogClick(changeEventArg, podNamespace, podName)" />
                    </td>
                </tr>
            }
        </tbody>
    </table>
</div>

<hr />

<h4>Logs</h4>

<button title="btn-log-autoscroll-top" class="btn btn-outline-info" @onclick="ChangeScrollToBottom">Auto scroll to bottom : @ScrollToBottom</button>
<button title="btn-log-clearlog-top" class="btn btn-outline-danger" @onclick="ClearLogs">Clear logs </button>

<div id="log-container">
    @foreach (var message in PodLogs)
    {
        <span class="log_line text">@message</span>
    }
</div>

@if (PodLogs.Count > 0)
{
    <button title="btn-log-autoscroll-bottom" class="btn btn-outline-info" @onclick="ChangeScrollToBottom">Auto scroll to bottom : @ScrollToBottom</button>
    <button title="btn-log-clearlog-bottom" class="btn btn-outline-danger" @onclick="ClearLogs">Clear logs </button>
}

@code {
    public BlockingCollection<V1Namespace> NamespaceList { get; set; } = new();

    public BlockingCollection<V1Deployment> Deployments { get; set; } = new();

    public BlockingCollection<V1Pod> Pods { get; set; } = new();

    public string? Error { get; set; }

    public KubernetesPageSettings Settings { get; set; } = new KubernetesPageSettings();

    protected override async Task OnInitializedAsync()
    {
        try
        {
            Settings = await UserPreference.GetAsync<KubernetesPageSettings>();

            var cookies = HttpContextAccessor.HttpContext?.Request.Cookies;

            var cookiesCollection = new System.Net.CookieContainer();

            if (cookies != null)
            {
                foreach (var c in cookies)
                {
                    cookiesCollection.Add(new System.Net.Cookie(c.Key, c.Value) { Domain = await JS.InvokeAsync<string>("window.GetHostname") });
                }
            }

            k8sHubConnection = new HubConnectionBuilder()
                .WithUrl(NavigationManager.ToAbsoluteUri("/K8sHub"), options =>
                {
                    options.Cookies = cookiesCollection;
                })
                .Build();

            await k8sHubConnection.StartAsync();

            _dashboardTask = RunK8sDashboard();

            logHubConnection = new HubConnectionBuilder()
                .WithUrl(NavigationManager.ToAbsoluteUri("/GetPodLog"), options =>
                {
                    options.Cookies = cookiesCollection;
                })
                .Build();

            await logHubConnection.StartAsync();
        }
        catch (Exception e)
        {
            Error = e.Message;
            Logger.LogError(e, e.Message);
        }
    }

    private HubConnection? k8sHubConnection;
    private CancellationTokenSource _dashboardToken = new();
    private Task? _dashboardTask;

    private HubConnection? logHubConnection;
    private BlockingCollection<string> PodLogs { get; set; } = new();
    private Dictionary<string, System.Threading.CancellationTokenSource> TokensBag { get; set; } = new();

    private async Task RunK8sDashboard()
    {
        try
        {
            await Task.WhenAll(new Task[]
            {
                Task.Run(async () =>
                {
                    var namespaceChannel = await k8sHubConnection.StreamAsChannelAsync<Pair<WatchEventType?, V1Namespace>>("Namespaces", _dashboardToken.Token);

                    while (await namespaceChannel.WaitToReadAsync(_dashboardToken.Token))
                    {
                        while (namespaceChannel.TryRead(out var @namespace))
                        {
                            if (@namespace.Item2 is null)
                            {
                                continue;
                            }

                            switch (@namespace.Item1)
                            {
                                case null:
                                case WatchEventType.Added:
                                    NamespaceList.Add(@namespace.Item2);
                                    break;
                                case WatchEventType.Bookmark:
                                    throw new NotImplementedException(WatchEventType.Bookmark.ToString());
                                case WatchEventType.Deleted:
                                    throw new NotImplementedException(WatchEventType.Deleted.ToString());
                                case WatchEventType.Error:
                                    throw new NotImplementedException(WatchEventType.Error.ToString());
                                case WatchEventType.Modified:
                                    throw new NotImplementedException(WatchEventType.Modified.ToString());
                                default:
                                    throw new InvalidOperationException($"Unknow {nameof(WatchEventType)} with value {@namespace.Item1}");
                            }

                            await InvokeAsync(() =>
                            {
                                StateHasChanged();
                            });
                        }
                    }
                }),
                Task.Run(async () =>
                {
                    var deploymentChannel = await k8sHubConnection.StreamAsChannelAsync<Pair<WatchEventType?, V1Deployment>>("Deployments", _dashboardToken.Token);

                    while (await deploymentChannel.WaitToReadAsync(_dashboardToken.Token))
                    {
                        while (deploymentChannel.TryRead(out var deployment))
                        {
                            if (deployment.Item2 is null)
                            {
                                continue;
                            }

                            switch (deployment.Item1)
                            {
                                case null:
                                case WatchEventType.Added:
                                    Deployments.Add(deployment.Item2);
                                    break;
                                case WatchEventType.Bookmark:
                                    throw new NotImplementedException(WatchEventType.Bookmark.ToString());
                                case WatchEventType.Deleted:
                                    throw new NotImplementedException(WatchEventType.Deleted.ToString());
                                case WatchEventType.Error:
                                    throw new NotImplementedException(WatchEventType.Error.ToString());
                                case WatchEventType.Modified:
                                    throw new NotImplementedException(WatchEventType.Modified.ToString());
                                default:
                                    throw new InvalidOperationException($"Unknow {nameof(WatchEventType)} with value {deployment.Item1}");
                            }

                            await InvokeAsync(() =>
                            {
                                StateHasChanged();
                            });
                        }
                    }
                }),
                Task.Run(async () =>
                {
                    var podChannel = await k8sHubConnection.StreamAsChannelAsync<Pair<WatchEventType?, V1Pod>>("Pods", _dashboardToken.Token);

                    while (await podChannel.WaitToReadAsync(_dashboardToken.Token))
                    {
                        while (podChannel.TryRead(out var pod))
                        {
                            if (pod.Item2 is null)
                            {
                                continue;
                            }

                            switch (pod.Item1)
                            {
                                case null:
                                case WatchEventType.Added:
                                    Pods.Add(pod.Item2);
                                    break;
                                case WatchEventType.Bookmark:
                                    throw new NotImplementedException(WatchEventType.Bookmark.ToString());
                                case WatchEventType.Deleted:
                                    throw new NotImplementedException(WatchEventType.Deleted.ToString());
                                case WatchEventType.Error:
                                    throw new NotImplementedException(WatchEventType.Error.ToString());
                                case WatchEventType.Modified:
                                    throw new NotImplementedException(WatchEventType.Modified.ToString());
                                default:
                                    throw new InvalidOperationException($"Unknow {nameof(WatchEventType)} with value {pod.Item1}");
                            }

                            await InvokeAsync(() =>
                            {
                                StateHasChanged();
                            });
                        }
                    }
                })
            });
        }
        catch (Exception e)
        {
            Logger.LogError(e.Message, e);
            Error = e.Message;
        }
    }

    private async Task OnPodLogClick(ChangeEventArgs args, string podNamespace, string podName)
    {
        var taskKey = $"{podNamespace}{podName}";

        if (TokensBag.TryGetValue(taskKey, out var tokenSourceCancellation))
        {
            tokenSourceCancellation.Cancel();

            TokensBag.Remove(taskKey);
        }
        else
        {
            var tokenSource = new System.Threading.CancellationTokenSource();

            var channel = await logHubConnection.StreamAsChannelAsync<string>("GetPodLog", podNamespace, podName, tokenSource.Token);

            TokensBag.Add(taskKey, tokenSource);

            while (await channel.WaitToReadAsync(tokenSource.Token))
            {
                while (channel.TryRead(out var log))
                {
                    PodLogs.Add(log);
                    StateHasChanged();
                    if (ScrollToBottom)
                    {
                        await JS.InvokeVoidAsync("window.scrollToBottom");
                    }
                }
            }
        }
    }

    private async Task OnDeploymentLogClick(ChangeEventArgs args, string deploymentNamespace, string deploymentName)
    {
        try
        {
            var taskList = new List<Task>
                ();

            foreach (var pod in Pods)
            {
                if (pod.Name().StartsWith(deploymentName))
                {
                    taskList.Add(OnPodLogClick(args, deploymentNamespace, pod.Name()));
                }
            }

            foreach (var task in taskList)
            {
                await task;
            }
        }
        catch (Exception e)
        {
            Error = e.Message;
            Logger.LogError(e, e.Message);
        }
    }

    private async Task DeleteNamespace(V1Namespace ns)
    {
        try
        {
            await Client.DeleteNamespaceAsync(ns.Metadata.Name, new V1DeleteOptions());
        }
        catch (Exception e)
        {
            Error = e.Message;
            Logger.LogError(e, e.Message);
        }

        //NamespaceList = await Client.ListNamespaceAsync();

        //Pods.Items = Pods.Items.Where(p =>
        //{
        //    if (p.Namespace() != ns.Metadata.Name)
        //    {
        //        return true;
        //    }

        //    var taskKey = $"{ns.Metadata.Name}{p.Metadata.Name}";

        //    if (TokensBag.TryGetValue(taskKey, out var tokenSourceCancellation))
        //    {
        //        tokenSourceCancellation.Cancel();

        //        TokensBag.Remove(taskKey);
        //    }

        //    return false;
        //}).ToList();

        //StateHasChanged();
    }

    private void ClearLogs()
    {
        while (PodLogs.TryTake(out _)) { }
    }

    private bool ScrollToBottom { get; set; }

    public void ChangeScrollToBottom()
    {
        ScrollToBottom = !ScrollToBottom;
    }

    public async ValueTask DisposeAsync()
    {
        if (logHubConnection is not null)
        {
            await logHubConnection.DisposeAsync();
        }

        if (k8sHubConnection is not null)
        {
            await k8sHubConnection.DisposeAsync();
        }
    }

    public void Dispose()
    {
        _dashboardToken.Cancel();

        try
        {
            _dashboardTask?.Wait();
        }
        catch (Exception e)
        {
            Console.Error.WriteLine(e.Message);
            Console.Error.WriteLine(e.StackTrace);
        }

        _dashboardTask.Dispose();
        _dashboardToken.Dispose();
    }

    public void Collapsing(string collapseId)
    {
        if (collapseId == "collapseNamespace")
        {
            Settings.NamespaceCollapseClass = string.IsNullOrEmpty(Settings.NamespaceCollapseClass) ? "collapse" : "";
        }
        else if (collapseId == "collapseDeployment")
        {
            Settings.DeploymentCollapseClass = string.IsNullOrEmpty(Settings.DeploymentCollapseClass) ? "collapse" : "";
        }
        else if (collapseId == "collapsePods")
        {
            Settings.PodsCollapseClass = string.IsNullOrEmpty(Settings.PodsCollapseClass) ? "collapse" : "";
        }

        UserPreference.SetAsync(Settings);
    }
}
