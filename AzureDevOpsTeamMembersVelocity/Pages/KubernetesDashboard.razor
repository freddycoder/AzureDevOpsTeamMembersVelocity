@page "/Kubernetes"
@using Microsoft.JSInterop
@using Microsoft.AspNetCore.Http
@inject k8s.IKubernetes Client
@inject NavigationManager NavigationManager
@inject ILogger<KubernetesDashboard> Logger
@inject IJSRuntime JS
@inject IHttpContextAccessor HttpContextAccessor
@inject IUserPreferenceRepository UserPreference
@attribute [Authorize]

@if (Error != null)
{
    <ul class="list-group mb-3">
        <li class="list-group-item list-group-item-danger">@Error</li>
    </ul>
}

<h3>Kubernetes</h3>

<div class="row">
    <button class="btn btn-primary"
            type="button"
            @onclick='() => Collapsing("collapseNamespace")'>
        Namespaces
    </button>
</div>


<div class="@Settings.NamespaceCollapseClass" id="collapseNamespace">
    <table class="table table-hover table-responsive">
        <caption>Table of kubernetes namespace</caption>
        <thead>
            <tr>
                <th>Name</th>
                <th>Creation time</th>
                <th>Phase</th>
                <th></th>
            </tr>
        </thead>
        <tbody>
            @foreach (var ns in NamespaceList.Values)
            {
                <tr>
                    <td>@ns.Metadata.Name</td>
                    <td>@ns.Metadata.CreationTimestamp</td>
                    <td>@ns.Status.Phase</td>
                    <td>
                        <button id="@string.Concat("ns-", ns.Metadata.Name)"
                                title="btn-delete-ns-@ns.Metadata.Name"
                                class="btn btn-danger"
                                @onclick="async (mea) => await DeleteNamespace(ns)">
                            Delete
                        </button>
                    </td>
                </tr>
            }
        </tbody>
    </table>
</div>

<hr />

<div class="row">
    <button class="btn btn-primary"
            type="button"
            @onclick='() => Collapsing("collapseDeployment")'>
        Deployments
    </button>
</div>

<div class="@Settings.DeploymentCollapseClass" id="collapseDeployment">
    <table class="table table-hover table-responsive">
        <caption>Table of kubernetes deployments</caption>
        <thead>
            <tr>
                <th>Name</th>
                <th>Creation time</th>
                <th>Ready</th>
                <th>Unavailable</th>
                <th></th>
            </tr>
        </thead>
        <tbody>
            @foreach (var deployment in Deployments.Values)
            {
                var deploymentNamespace = deployment.Namespace();
                var deploymentName = deployment.Name();

                <tr>
                    <td>@deployment.Metadata.Name</td>
                    <td>@deployment.Metadata.CreationTimestamp</td>
                    <td>@deployment.Status.ReadyReplicas</td>
                    <td>@deployment.Status.UnavailableReplicas</td>
                    <td>
                        <input id="@string.Concat(deploymentNamespace, deploymentName)"
                               title="button-pod-@deployment.Metadata.Name"
                               type="checkbox"
                               class="form-check"
                               @onchange="async (changeEventArg) => await OnDeploymentLogClick(changeEventArg, deploymentNamespace, deploymentName)" />
                    </td>
                </tr>
            }
        </tbody>
    </table>
</div>

<hr />

<div class="row">
    <button class="btn btn-primary"
            type="button"
            @onclick='() => Collapsing("collapsePods")'>
        Pods
    </button>
</div>

<div class="@Settings.PodsCollapseClass" id="collapsePods">
    <table class="table table-hover table-responsive">
        <caption>Table of kubernetes pods</caption>
        <thead>
            <tr>
                <th>Name</th>
                <th>Creation time</th>
                <th>Phase</th>
                <th>Reason</th>
                <th>Select</th>
            </tr>
        </thead>
        <tbody>
            @foreach (var pod in Pods.Values)
            {
                var podNamespace = pod.Namespace();
                var podName = pod.Name();

                <tr>
                    <td>@pod.Metadata.Name</td>
                    <td>@pod.Metadata.CreationTimestamp</td>
                    <td>@pod.Status.Phase</td>
                    <td>@pod.Status.Reason</td>
                    <td>
                        <input id="@string.Concat(podNamespace, podName)"
                               title="button-pod-@pod.Metadata.Name"
                               type="checkbox"
                               class="form-check"
                               @onchange="async (changeEventArg) => await OnPodLogClick(changeEventArg, podNamespace, podName)" />
                    </td>
                </tr>
            }
        </tbody>
    </table>
</div>

<hr />

<h4>Logs</h4>

<button title="btn-log-autoscroll-top" class="btn btn-outline-info" @onclick="ChangeScrollToBottom">Auto scroll to bottom : @ScrollToBottom</button>
<button title="btn-log-clearlog-top" class="btn btn-outline-danger" @onclick="ClearLogs">Clear logs </button>

<div id="log-container">
    @foreach (var message in PodLogs)
    {
        <span class="log_line text">@message</span>
    }
</div>

@if (PodLogs.Count > 0)
{
    <button title="btn-log-autoscroll-bottom" class="btn btn-outline-info" @onclick="ChangeScrollToBottom">Auto scroll to bottom : @ScrollToBottom</button>
    <button title="btn-log-clearlog-bottom" class="btn btn-outline-danger" @onclick="ClearLogs">Clear logs </button>
}

@code {
    public ConcurrentDictionary<string, V1Namespace> NamespaceList { get; set; } = new();

    public ConcurrentDictionary<string, V1Deployment> Deployments { get; set; } = new();

    public ConcurrentDictionary<string, V1Pod> Pods { get; set; } = new();

    public string? Error { get; set; }

    public KubernetesPageSettings Settings { get; set; } = new KubernetesPageSettings();

    protected override async Task OnInitializedAsync()
    {
        try
        {
            Settings = await UserPreference.GetAsync<KubernetesPageSettings>();

            var cookies = HttpContextAccessor.HttpContext?.Request.Cookies;

            var cookiesCollection = new System.Net.CookieContainer();

            if (cookies != null)
            {
                foreach (var c in cookies)
                {
                    cookiesCollection.Add(new System.Net.Cookie(c.Key, c.Value) { Domain = await JS.InvokeAsync<string>("window.GetHostname") });
                }
            }

            k8sHubConnection = new HubConnectionBuilder()
                .WithUrl(NavigationManager.ToAbsoluteUri("/K8sHub"), options =>
                {
                    options.Cookies = cookiesCollection;
                })
                .Build();

            await k8sHubConnection.StartAsync();

            _dashboardTask = RunK8sDashboard();

            logHubConnection = new HubConnectionBuilder()
                .WithUrl(NavigationManager.ToAbsoluteUri("/GetPodLog"), options =>
                {
                    options.Cookies = cookiesCollection;
                })
                .Build();

            await logHubConnection.StartAsync();
        }
        catch (Exception e)
        {
            Error = e.Message;
            Logger.LogError(e, e.Message);
        }
    }

    private HubConnection? k8sHubConnection;
    private CancellationTokenSource _dashboardToken = new();
    private Task? _dashboardTask;

    private HubConnection? logHubConnection;
    private BlockingCollection<string> PodLogs { get; set; } = new();
    private Dictionary<string, System.Threading.CancellationTokenSource> TokensBag { get; set; } = new();

    private async Task RunK8sDashboard()
    {
        try
        {
            await Task.WhenAll(new Task[]
            {
                Task.Run(async () =>
                {
                    var namespaceChannel = await k8sHubConnection.StreamAsChannelAsync<Pair<WatchEventType?, V1Namespace>>("Namespaces", _dashboardToken.Token);

                    while (await namespaceChannel.WaitToReadAsync(_dashboardToken.Token))
                    {
                        while (namespaceChannel.TryRead(out var @namespace))
                        {
                            if (@namespace.Item2 is null)
                            {
                                continue;
                            }

                            switch (@namespace.Item1)
                            {
                                case null:
                                case WatchEventType.Added:
                                    if (!NamespaceList.TryAdd(@namespace.Item2.Metadata.Name, @namespace.Item2))
                                    {
                                        var message = $"Failed to add namespace {@namespace.Item2.Metadata.Name}";
                                        Logger.LogError(message);
                                        Error = message;
                                    }
                                    break;
                                case WatchEventType.Bookmark:
                                    Logger.LogInformation(WatchEventType.Bookmark.ToString());
                                    Logger.LogInformation(JsonSerializer.Serialize(@namespace.Item2));
                                    break;
                                case WatchEventType.Deleted:
                                    if (!NamespaceList.Remove(@namespace.Item2.Metadata.Name, out var _))
                                    {
                                        var message = $"Failed to remove namespace {@namespace.Item2.Metadata.Name}";
                                        Logger.LogError(message);
                                        Error = message;
                                    }
                                    break;
                                case WatchEventType.Error:
                                    Logger.LogError(WatchEventType.Error.ToString());
                                    Logger.LogError(JsonSerializer.Serialize(@namespace.Item2));
                                    break;
                                case WatchEventType.Modified:
                                    var key = @namespace.Item2.Metadata.Name;
                                    if ((NamespaceList.TryGetValue(key, out var oldValue) && NamespaceList.TryUpdate(key, @namespace.Item2, oldValue)) == false)
                                    {
                                        var message = $"Failed to update namespace {@namespace.Item2.Metadata.Name}";
                                        Logger.LogError(message);
                                        Error = message;
                                    }
                                    break;
                                default:
                                    throw new InvalidOperationException($"Unknow {nameof(WatchEventType)} with value {@namespace.Item1}");
                            }

                            await InvokeAsync(() =>
                            {
                                StateHasChanged();
                            });
                        }
                    }
                }),
                Task.Run(async () =>
                {
                    var deploymentChannel = await k8sHubConnection.StreamAsChannelAsync<Pair<WatchEventType?, V1Deployment>>("Deployments", _dashboardToken.Token);

                    while (await deploymentChannel.WaitToReadAsync(_dashboardToken.Token))
                    {
                        while (deploymentChannel.TryRead(out var deployment))
                        {
                            if (deployment.Item2 is null)
                            {
                                continue;
                            }

                            var key = $"{deployment.Item2.Metadata.NamespaceProperty}-{deployment.Item2.Metadata.Name}";

                            switch (deployment.Item1)
                            {
                                case null:
                                case WatchEventType.Added:
                                    if (!Deployments.TryAdd(key, deployment.Item2))
                                    {
                                        var message = $"Failed to add deployment {deployment.Item2.Metadata.Name}";
                                        Logger.LogError(message);
                                        Error = message;
                                    }
                                    break;
                                case WatchEventType.Bookmark:
                                    Logger.LogInformation(WatchEventType.Bookmark.ToString());
                                    Logger.LogInformation(JsonSerializer.Serialize(deployment.Item2));
                                    break;
                                case WatchEventType.Deleted:
                                    if (!Deployments.Remove(key, out var removedDeployment))
                                    {
                                        var message = $"Failed to remove deployment {deployment.Item2.Metadata.Name}";
                                        Logger.LogError(message);
                                        Error = message;
                                    }
                                    break;
                                case WatchEventType.Error:
                                    Logger.LogError(WatchEventType.Error.ToString());
                                    Logger.LogError(JsonSerializer.Serialize(deployment.Item2));
                                    break;
                                case WatchEventType.Modified:
                                    if ((Deployments.TryGetValue(key, out var oldValue) && Deployments.TryUpdate(key, deployment.Item2, oldValue)) == false)
                                    {
                                        var message = $"Failed to update deployment {deployment.Item2.Metadata.Name}";
                                        Logger.LogError(message);
                                        Error = message;
                                    }
                                    break;
                                default:
                                    throw new InvalidOperationException($"Unknow {nameof(WatchEventType)} with value {deployment.Item1}");
                            }

                            await InvokeAsync(() =>
                            {
                                StateHasChanged();
                            });
                        }
                    }
                }),
                Task.Run(async () =>
                {
                    var podChannel = await k8sHubConnection.StreamAsChannelAsync<Pair<WatchEventType?, V1Pod>>("Pods", _dashboardToken.Token);

                    List<Task> taskList = new();

                    while (await podChannel.WaitToReadAsync(_dashboardToken.Token))
                    {
                        while (podChannel.TryRead(out var pod))
                        {
                            if (pod.Item2 is null)
                            {
                                continue;
                            }

                            var @namespace = pod.Item2.Metadata.NamespaceProperty;
                            var podName = pod.Item2.Metadata.Name;
                            var key = $"{@namespace}-{pod.Item2.Metadata.Name}";

                            switch (pod.Item1)
                            {
                                case null:
                                case WatchEventType.Added:
                                    if (Pods.TryAdd(key, pod.Item2))
                                    {
                                        if (DeployementCheckedForLogs.Any(d => pod.Item2.Metadata.Name.StartsWith(d)))
                                        {
                                            taskList.Add(ListenTopPodLogs(PodLogsTaskKey(@namespace, podName), @namespace, podName));
                                        }
                                    }
                                    else
                                    {
                                        var message = $"Failed to add pod {pod.Item2.Metadata.Name}";
                                        Logger.LogError(message);
                                        Error = message;
                                    }
                                    break;
                                case WatchEventType.Bookmark:
                                    Logger.LogInformation(WatchEventType.Bookmark.ToString());
                                    Logger.LogInformation(JsonSerializer.Serialize(pod.Item2));
                                    break;
                                case WatchEventType.Deleted:
                                    if (Pods.Remove(key, out var podDeleted))
                                    {
                                        var taskKey = PodLogsTaskKey(podDeleted.Metadata.NamespaceProperty, podDeleted.Metadata.Name);

                                        if (TokensBag.TryGetValue(taskKey, out var tokenSourceCancellation))
                                        {
                                            tokenSourceCancellation.Cancel();

                                            TokensBag.Remove(taskKey);
                                        }
                                    }
                                    else
                                    {
                                        var message = $"Failed to remove pod {pod.Item2.Metadata.Name}";
                                        Logger.LogError(message);
                                        Error = message;
                                    }
                                    break;
                                case WatchEventType.Error:
                                    Logger.LogError(WatchEventType.Error.ToString());
                                    Logger.LogError(JsonSerializer.Serialize(pod.Item2));
                                    break;
                                case WatchEventType.Modified:
                                    if ((Pods.TryGetValue(key, out var oldValue) && Pods.TryUpdate(key, pod.Item2, oldValue)))
                                    {
                                        var taskKey = PodLogsTaskKey(pod.Item2.Metadata.NamespaceProperty, pod.Item2.Metadata.Name);

                                        if (TokensBag.TryGetValue(taskKey, out var token))
                                        {
                                            Logger.LogWarning("May need to do something, for now this scenario is not fully implemented");
                                            Logger.LogWarning(WatchEventType.Modified.ToString());
                                            Logger.LogWarning(JsonSerializer.Serialize(pod.Item2));
                                        }
                                    }
                                    else
                                    {
                                        var message = $"Failed to update pod {pod.Item2.Metadata.Name}";
                                        Logger.LogError(message);
                                        Error = message;
                                    }
                                    break;
                                default:
                                    throw new InvalidOperationException($"Unknow {nameof(WatchEventType)} with value {pod.Item1}");
                            }

                            await InvokeAsync(() =>
                            {
                                StateHasChanged();
                            });
                        }
                    }

                    await Task.WhenAll(taskList);
                })
            });
        }
        catch (Exception e)
        {
            Logger.LogError(e.Message, e);
            Error = $"RunK8sDashboarde: {e.Message}{Environment.NewLine}You may want to reload the page to fully restore the live refresh";
        }
    }

    private async Task OnPodLogClick(ChangeEventArgs args, string podNamespace, string podName)
    {
        var taskKey = PodLogsTaskKey(podNamespace, podName);

        if (TokensBag.TryGetValue(taskKey, out var tokenSourceCancellation))
        {
            tokenSourceCancellation.Cancel();

            TokensBag.Remove(taskKey);
        }
        else
        {
            await ListenTopPodLogs(taskKey, podNamespace, podName);
        }
    }

    public async Task ListenTopPodLogs(string taskKey, string podNamespace, string podName)
    {
        var tokenSource = new System.Threading.CancellationTokenSource();

        var channel = await logHubConnection.StreamAsChannelAsync<string>("GetPodLog", podNamespace, podName, tokenSource.Token);

        TokensBag.Add(taskKey, tokenSource);

        while (await channel.WaitToReadAsync(tokenSource.Token))
        {
            while (channel.TryRead(out var log))
            {
                PodLogs.Add(log);
                StateHasChanged();
                if (ScrollToBottom)
                {
                    await JS.InvokeVoidAsync("window.scrollToBottom");
                }
            }
        }
    }

    public string PodLogsTaskKey(string podNamespace, string podName) => $"{podNamespace}{podName}";

    public HashSet<string> DeployementCheckedForLogs { get; } = new();

    private async Task OnDeploymentLogClick(ChangeEventArgs args, string deploymentNamespace, string deploymentName)
    {
        try
        {
            DeployementCheckedForLogs.Add(deploymentName);

            List<Task> taskList = new();

            foreach (var pod in Pods.Values)
            {
                if (pod.Name().StartsWith(deploymentName))
                {
                    taskList.Add(OnPodLogClick(args, deploymentNamespace, pod.Name()));
                }
            }

            foreach (var task in taskList)
            {
                await task;
            }
        }
        catch (Exception e)
        {
            try
            {
                DeployementCheckedForLogs.Remove($"{deploymentNamespace}-{deploymentName}");
            }
            catch { }

            Error = e.Message;
            Logger.LogError(e, e.Message);
        }
    }

    private async Task DeleteNamespace(V1Namespace ns)
    {
        try
        {
            await Client.DeleteNamespaceAsync(ns.Metadata.Name, new V1DeleteOptions());
        }
        catch (Exception e)
        {
            Error = e.Message;
            Logger.LogError(e, e.Message);
        }
    }

    private void ClearLogs()
    {
        while (PodLogs.TryTake(out _)) { }
    }

    private bool ScrollToBottom { get; set; }

    public void ChangeScrollToBottom()
    {
        ScrollToBottom = !ScrollToBottom;
    }

    public async ValueTask DisposeAsync()
    {
        if (logHubConnection is not null)
        {
            await logHubConnection.DisposeAsync();
        }

        if (k8sHubConnection is not null)
        {
            await k8sHubConnection.DisposeAsync();
        }
    }

    public void Dispose()
    {
        _dashboardToken.Cancel();

        try
        {
            _dashboardTask?.Wait();
        }
        catch (Exception e)
        {
            Console.Error.WriteLine(e.Message);
            Console.Error.WriteLine(e.StackTrace);
        }

        _dashboardTask?.Dispose();
        _dashboardToken.Dispose();
    }

    public void Collapsing(string collapseId)
    {
        if (collapseId == "collapseNamespace")
        {
            Settings.NamespaceCollapseClass = string.IsNullOrEmpty(Settings.NamespaceCollapseClass) ? "collapse" : "";
        }
        else if (collapseId == "collapseDeployment")
        {
            Settings.DeploymentCollapseClass = string.IsNullOrEmpty(Settings.DeploymentCollapseClass) ? "collapse" : "";
        }
        else if (collapseId == "collapsePods")
        {
            Settings.PodsCollapseClass = string.IsNullOrEmpty(Settings.PodsCollapseClass) ? "collapse" : "";
        }

        UserPreference.SetAsync(Settings);
    }
}
